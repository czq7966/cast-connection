export as namespace ADHOCCAST;
// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   events

import { EventEmitter } from "events";
import { EventEmitter } from 'events';

interface IBase {
    notDestroyed: boolean;
    eventEmitter: EventEmitter;
    destroy(): any;
}
class Base {
    notDestroyed: boolean;
    eventEmitter: EventEmitter;
    constructor();
    destroy(): void;
}

enum ECustomEvents {
    message = "room-message",
    openRoom = "room-open",
    joinRoom = "room-join",
    closeRoom = "room-close",
    leaveRoom = "room-leave"
}
interface IUserQuery {
    roomid?: string;
    password?: string;
    isOwner?: boolean;
    max?: number;
    from?: string;
    to?: string;
    msg?: any;
}
enum EClientBaseEvents {
    connect = "connect",
    connect_error = "connect_error",
    connect_timeout = "connect_timeout",
    connecting = "connecting",
    disconnect = "disconnect",
    error = "error",
    reconnect = "reconnect",
    reconnect_attempt = "reconnect_attempt",
    reconnect_failed = "reconnect_failed",
    reconnect_error = "reconnect_error",
    reconnecting = "reconnecting"
}
class Client {
    eventEmitter: EventEmitter;
    socket: SocketIOClient.Socket;
    url: string;
    constructor(url?: string);
    destroy(): void;
    id(): string;
    connected(): boolean;
    connect(url?: string): Promise<any>;
    disconnect(): void;
    initEvents(socket: SocketIOClient.Socket): void;
    unInitEvents(socket: SocketIOClient.Socket): void;
    openRoom(query: IUserQuery, url?: string): Promise<any>;
    joinRoom(query: IUserQuery): Promise<string>;
    leaveRoom(query: IUserQuery): Promise<any>;
    sendMessage(query: IUserQuery): Promise<any>;
}

enum ECodecs {
    default = "default",
    vp8 = "vp8",
    vp9 = "vp9",
    h264 = "h264"
}
enum EPlatform {
    reactnative = "reactnative",
    browser = "browser"
}
class Config {
    static platform: EPlatform;
    bandwidth: number;
    codec: string;
    iceServers: RTCIceServer[];
    rtcConfig: RTCConfiguration;
    constructor();
}

class Connection extends Base {
    signaler: Signaler;
    rooms: Rooms;
    dispatcher: Dispatcher;
    stream: MediaStream;
    constructor(url: string);
    destroy(): void;
    initEvents(): void;
    unInitEvents(): void;
    id(): string;
    openRoom(query: IUserQuery, url?: string): Promise<any>;
    joinRoom(query: IUserQuery): Promise<any>;
    leaveRoom(query: IUserQuery): Promise<any>;
    onDisconnect: (reason: any) => void;
    onCloseRoom: () => void;
    close(): void;
}

interface IDispatcher extends IBase {
}
class Dispatcher extends Base {
    signaler: Signaler;
    rooms: Rooms;
    constructor(signaler: Signaler, rooms: Rooms);
    destroy(): void;
    initEvents(): void;
    unInitEvents: () => void;
    onJoinRoom: (query: IUserQuery) => void;
    onLeaveRoom: (query: IUserQuery) => void;
    onCloseRoom: (query: IUserQuery) => void;
    onMessage: (query: IUserQuery) => void;
}

enum ERTCPeerEvents {
    onconnectionstatechange = "connectionstatechange",
    ondatachannel = "datachannel",
    onicecandidate = "icecandidate",
    onicecandidateerror = "icecandidateerror",
    oniceconnectionstatechange = "iceconnectionstatechange",
    onicegatheringstatechange = "icegatheringstatechange",
    onnegotiationneeded = "negotiationneeded",
    onsignalingstatechange = "signalingstatechange",
    onstatsended = "statsended",
    ontrack = "track",
    onstream = "stream",
    onaddstream = "addstream",
    onrecvstream = "onrecvstream",
    onrecvstreaminactive = "onrecvstreaminactive",
    onsendstreaminactive = "onsendstreaminactive"
}
enum EPeerEvents {
    ongetconfig = "ongetconfig"
}
class Peer extends Base {
    config: Config;
    user: IUser;
    streams: Streams;
    constructor(user: IUser);
    destroy(): void;
    close(): void;
    initEvents(): void;
    unInitEvents(): void;
    initRTCEvents(rtc: RTCPeerConnection): void;
    unInitRTCEvents(rtc: RTCPeerConnection): void;
    rtc(): RTCPeerConnection;
    doICE(stream: MediaStream): void;
    addSendStream(stream: MediaStream): boolean;
    getConfig(): Config;
    createOffer(): Promise<any>;
    sendOffer(sdp?: RTCSessionDescriptionInit): void;
    createAnswer(): Promise<any>;
    createAnswer_reactnative(): Promise<any>;
    createAnswer_browser(): Promise<any>;
    sendAnswer(sdp?: RTCSessionDescriptionInit): void;
    onIceCandidate: (ev: RTCPeerConnectionIceEvent) => void;
    stopSharing(): Promise<any>;
    onOffer: (data: any) => void;
    onOffer_browser: (data: any) => void;
    onOffer_reactnative: (data: any) => void;
    onAnswer: (data: any) => void;
    onCandidate: (data: any) => void;
    onCandidate_browser: (data: any) => void;
    onCandidate_reactnative: (data: any) => void;
    onIceComplete: () => void;
    onTrack: (ev: RTCTrackEvent) => void;
    onStream: (ev: any) => void;
    onAddStream: (ev: Event) => void;
    onRecvStream: (stream: MediaStream) => void;
}

enum ERoomEvents {
    onadduser = "onadduser"
}
interface IRoomParams {
    roomid: string;
    password: string;
    max?: number;
    Signaler?: Signaler;
}
interface IRoom extends IBase, IRoomParams {
    users: {
        [id: string]: IUser;
    };
    streams: Streams;
    getOwner(): IUser;
    isOwner(socketId: string): boolean;
    addUser(user: IUser): IUser;
    delUser(socketId: string): any;
    currUser(): IUser;
    addSendStream(stream: MediaStream, user?: IUser): any;
}
class Room extends Base implements IRoom {
    roomid: string;
    password: string;
    max: number;
    signaler: Signaler;
    users: {
        [id: string]: IUser;
    };
    streams: Streams;
    constructor(room: IRoomParams);
    destroy(): void;
    initEvents(): void;
    unInitEvents(): void;
    onJoinRoom: (query: IUserQuery) => void;
    onLeaveRoom: (query: IUserQuery) => void;
    onCloseRoom: (query: IUserQuery) => void;
    onMessage: (query: IUserQuery) => void;
    onRecvStream: (stream: MediaStream, user: IUser) => void;
    onIceConnectionStateChange: (ev: RTCTrackEvent, user: IUser) => void;
    getOwner(): IUser;
    isOwner(socketId: string): boolean;
    addUser(user: IUser): IUser;
    delUser(socketId: string): void;
    clearUsers(): void;
    getUser(socketId: string): IUser;
    getUsers(): Array<IUser>;
    currUser(): IUser;
    addSendStream(stream: MediaStream, user?: IUser): void;
    sendStreamsToUser(user?: IUser): void;
    close(): void;
}

enum ERoomsEvents {
    onnewroom = "onnewroom"
}
class Rooms extends Base {
    signaler: Signaler;
    rooms: {
        [id: string]: Room;
    };
    constructor(signaler: Signaler);
    destroy(): void;
    initEvents(): void;
    unInitEvents(): void;
    count(): number;
    onCloseRoom: (query: IUserQuery) => void;
    newRoom(roomid: string, password?: string): Room;
    getRoom(roomid: string): Room;
    delRoom(roomid: string): void;
    close(): void;
}

interface ISignalerMessage {
    type: ESignalerMessageType;
    data?: any;
}
enum ESignalerMessageType {
    offer = "message-offer",
    answer = "message-answer",
    candidate = "message-candidate",
    icecomplete = "message-icecomplete",
    hello = "message-hello",
    ready = "message-ready"
}
class Signaler extends Client {
}

class Streams extends Base {
    owner: any;
    sendStreams: {
        [id: string]: MediaStream;
    };
    recvStreams: {
        [id: string]: MediaStream;
    };
    constructor(owner: any);
    destroy(): void;
    addSendStream(stream: MediaStream): void;
    removeSendStream(id: string): void;
    getSendStream(id: string): MediaStream;
    getSendStreams(): Array<MediaStream>;
    onSendStreamInactive(stream: MediaStream): void;
    stopSendStreams(): Promise<any>;
    stopSendStream(id: string): Promise<any>;
    addRecvStream(stream: MediaStream): void;
    removeRecvStream(id: string): void;
    getRecvStream(id: string): MediaStream;
    getRecvStreams(): Array<MediaStream>;
    onRecvStreamInactive(stream: MediaStream): void;
    stopRecvStreams(): Promise<any>;
    stopRecvStream(id: string): Promise<any>;
}

interface IUserParams {
    socketId: string;
    isOwner: boolean;
    isReady?: boolean;
    signaler?: Signaler;
    peer?: Peer;
    room?: Room;
    streams?: Streams;
    video?: HTMLVideoElement;
}
interface IUser extends IBase, IUserParams {
    initEvents(): any;
    unInitEvents(): any;
    onMessage(query: IUserQuery): any;
    onReady(query: IUserQuery): any;
    stopSharing(): Promise<any>;
    imReady(): any;
    sayHello(to?: string): any;
    addSendStream(stream: MediaStream): any;
    addSendStreams(streams: Array<MediaStream>): any;
    doICE(): any;
    sendMessage(msg: any): any;
    close(): any;
}
class User extends Base implements IUser {
    socketId: string;
    isOwner: boolean;
    isReady: boolean;
    signaler: Signaler;
    peer: Peer;
    room: Room;
    streams: Streams;
    constructor(user: IUserParams);
    destroy(): void;
    close(): void;
    initEvents(): void;
    unInitEvents(): void;
    onMessage: (query: IUserQuery) => void;
    onReady(query: IUserQuery): void;
    onIceConnectionStateChange: (ev: Event) => void;
    onRecvStream: (stream: MediaStream) => void;
    stopSharing(): Promise<any>;
    imReady(): void;
    sayHello(to?: string): void;
    sendMessage(msg: any): void;
    addSendStream(stream: MediaStream): void;
    addSendStreams(streams: Array<MediaStream>): void;
    doICE(): void;
    isCurrUser(): boolean;
}

var WebRTC: any;
function AssignWebRTC(rnWebRTC: any): void;
{ WebRTC, AssignWebRTC };

